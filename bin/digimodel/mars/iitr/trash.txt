package fun.deepak.cool;

import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.util.ArrayList;

import org.omg.CORBA.Bounds;
import org.opencv.core.Core;
import org.opencv.core.CvType;
import org.opencv.core.Mat;
import org.opencv.videoio.VideoCapture;

import com.sun.org.apache.xalan.internal.xsltc.compiler.sym;
 
public class HelloCv {
	
	public static int requestFrame = 0;
	
    public static void main(String[] args) {
    	
    	int currentFrame = 0;
    	float speed = 0,delay = 0;
    	int currentError = 0;
    	int lastError = 0;
    	int sumError = 0;
    	float kp = 0.5f,
    		  kd = 0.5f,
    		  ki = 0;
    	
        System.loadLibrary(Core.NATIVE_LIBRARY_NAME);
        VideoCapture cap = new VideoCapture("/home/deepak/Downloads/kayden.mp4");
        Mat[] myMat = new Mat[52];
        
        KeyListener listener = new KeyListener() {
			
			@Override
			public void keyTyped(KeyEvent e) {
				if(Character.isDigit(e.getKeyChar()))
				{
					requestFrame = e.getKeyChar()-48;
					requestFrame *= 5;
				}
			}
			
			@Override
			public void keyReleased(KeyEvent e) {
				// TODO Auto-generated method stub
				
			}
			
			@Override
			public void keyPressed(KeyEvent e) {
				// TODO Auto-generated method stub
				
			}
		};
        
        ImageFrame imageFrame = new ImageFrame();
        imageFrame.addKeyListener(listener);
     
        for (int i = 0; i < 200; i++) 
        {
        	myMat[i] = new Mat();
            cap.read(myMat[i]);
            if(myMat[i].empty())
            	break;
		}
        imageFrame.show(myMat[0]);
        while(true)
        {
        	currentError = requestFrame-currentFrame;
        	speed = kp*currentError - kd * (currentError-lastError);// + (ki * sumError);
        	currentFrame = currentFrame + (int)speed;
        	if(currentFrame>50)
        		currentFrame = 50;
        	if(currentFrame <0)
        		currentFrame = 0;
        	imageFrame.show(myMat[currentFrame]);
        	System.out.println(requestFrame+"     "+currentFrame+"     "+speed);
        	lastError = currentError;
        }
    }
}





	public String getNextWord()
	{
		try 
		{
			serialPort.writeByte((byte)1);
			serialPort.writeByte((byte)1);
			serialPort.writeByte((byte)1);
			serialPort.writeByte((byte)1);
			serialPort.writeByte((byte)1);
		} 
		catch (SerialPortException e1) 
		{
			e1.printStackTrace();
		}
		String tmp = "";
		try 
		{
			tmp += serialPort.readBytes();
		} 
		catch (SerialPortException e) 
		{
			e.printStackTrace();
		}
		while(!tmp.contains(new String(""+'\n')))
		{
			System.out.println("in read loop");
			try 
			{
				tmp += serialPort.readBytes(1);
			} 
			catch (SerialPortException e) 
			{
				e.printStackTrace();
			}
		}
		return tmp;
	}
	
	
	
	
	KeyListener keyListener = new KeyListener() {
			
			@Override
			public void keyTyped(KeyEvent arg0) {
				// TODO Auto-generated method stub
				
			}
			
			@Override
			public void keyReleased(KeyEvent arg0) {
				// TODO Auto-generated method stub
			}
			
			@Override
			public void keyPressed(KeyEvent arg0) {
				// TODO Auto-generated method stub
				camera.read(frame);
				Core.split(frame, lRgb);
				mR = lRgb.get(2);
			    imageFrameOriginal.show(frame);
				if(arg0.getKeyChar() == 'l')
				{
					Imgproc.threshold(mR, mRThreshold, val++, 255, 0);
					imageFrameR.show(mRThreshold);
				}
				if(arg0.getKeyChar() == 'k')
				{
					Imgproc.threshold(mR, mRThreshold, val--, 255, 0);
					imageFrameR.show(mRThreshold);
				}
				System.out.println(val);
			}
		};
		imageFrameR.addKeyListener(keyListener);
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		package digimodel.mars.iitr;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import org.opencv.core.Core;
import org.opencv.core.CvType;
import org.opencv.core.Mat;
import org.opencv.core.MatOfPoint;
import org.opencv.core.Scalar;
import org.opencv.imgproc.Imgproc;

public class ColorBlobDetector {
	// Lower and Upper bounds for range checking in HSV color space
	private Scalar mLowerBound = new Scalar(0);
	private Scalar mUpperBound = new Scalar(0);
	// Minimum contour area in percent for contours filtering
	private static double mMinContourArea = 0.1;
	// Color radius for range checking in HSV color space
	private Scalar mColorRadius = new Scalar(25, 50, 50, 0);
	private Mat mSpectrum = new Mat();
	private List<MatOfPoint> mContours = new ArrayList<MatOfPoint>();
	// Cache
	Mat mPyrDownMat = new Mat();
	Mat mHsvMat = new Mat();
	Mat mMask = new Mat();
	Mat mDilatedMask = new Mat();
	Mat mHierarchy = new Mat();

	public void setColorRadius(Scalar radius) {
		mColorRadius = radius;
	}

	public void setHsvColor(Scalar hsvColor) {
		double minH = (hsvColor.val[0] >= mColorRadius.val[0]) ? hsvColor.val[0] - mColorRadius.val[0] : 0;
		double maxH = (hsvColor.val[0] + mColorRadius.val[0] <= 255) ? hsvColor.val[0] + mColorRadius.val[0] : 255;
		mLowerBound.val[0] = minH;
		mUpperBound.val[0] = maxH;
		mLowerBound.val[1] = hsvColor.val[1] - mColorRadius.val[1];
		mUpperBound.val[1] = hsvColor.val[1] + mColorRadius.val[1];
		mLowerBound.val[2] = hsvColor.val[2] - mColorRadius.val[2];
		mUpperBound.val[2] = hsvColor.val[2] + mColorRadius.val[2];
		mLowerBound.val[3] = 0;
		mUpperBound.val[3] = 255;
		Mat spectrumHsv = new Mat(1, (int) (maxH - minH), CvType.CV_8UC3);
		for (int j = 0; j < maxH - minH; j++) {
			byte[] tmp = { (byte) (minH + j), (byte) 255, (byte) 255 };
			spectrumHsv.put(0, j, tmp);
		}
		Imgproc.cvtColor(spectrumHsv, mSpectrum, Imgproc.COLOR_HSV2RGB_FULL, 4);
	}

	public Mat getSpectrum() {
		return mSpectrum;
	}

	public void setMinContourArea(double area) {
		mMinContourArea = area;
	}

	public void process(Mat rgbaImage) {
		Imgproc.pyrDown(rgbaImage, mPyrDownMat);
		Imgproc.pyrDown(mPyrDownMat, mPyrDownMat);
		Imgproc.cvtColor(mPyrDownMat, mHsvMat, Imgproc.COLOR_RGB2HSV_FULL);
		Core.inRange(mHsvMat, mLowerBound, mUpperBound, mMask);
		Imgproc.dilate(mMask, mDilatedMask, new Mat());
		List<MatOfPoint> contours = new ArrayList<MatOfPoint>();
		Imgproc.findContours(mDilatedMask, contours, mHierarchy, Imgproc.RETR_EXTERNAL, Imgproc.CHAIN_APPROX_SIMPLE);
		// Find max contour area
		double maxArea = 0;
		Iterator<MatOfPoint> each = contours.iterator();
		while (each.hasNext()) {
			MatOfPoint wrapper = each.next();
			double area = Imgproc.contourArea(wrapper);
			if (area > maxArea)
				maxArea = area;
		}
		// Filter contours by area and resize to fit the original image size
		mContours.clear();
		each = contours.iterator();
		while (each.hasNext()) {
			MatOfPoint contour = each.next();
			if (Imgproc.contourArea(contour) > mMinContourArea * maxArea) {
				Core.multiply(contour, new Scalar(4, 4), contour);
				mContours.add(contour);
			}
		}
	}

	public List<MatOfPoint> getContours() {
		return mContours;
	}
}
		